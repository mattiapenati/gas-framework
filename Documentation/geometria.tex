\documentclass[a4paper,10pt,twoside]{amsart}

\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{amsmath, amsfonts, amsthm, amsopn, amssymb}
\usepackage{braket}
\usepackage{mathrsfs}
%\usepackage{stmaryrd}
%\usepackage{fullpage}
\usepackage{indentfirst}
\usepackage{graphicx, color}
\usepackage{listings}

\ifx\pdfoutput\undefined
\else
	\usepackage[colorlinks,pdftex,hyperindex,pdfpagelabels]{hyperref}
	\usepackage{thumbpdf}
\fi

% Informazioni
\title{Geometry}
\author{Alfonso Fascì, Davide Ferrarese, Mattia Penati}

\newtheorem{theorem}{Teorema}[section]
\newtheorem{corollary}[theorem]{Corollario}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposizione}

\theoremstyle{remark}
\newtheorem{nota}[theorem]{Nota}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definizione}

% Numeric sets
\newcommand{\N}{\mathbb N}
\newcommand{\Z}{\mathbb Z}
\newcommand{\Q}{\mathbb Q}
\newcommand{\R}{\mathbb R}
\newcommand{\C}{\mathbb C}

% Greek letters
% \renewcommand{\theta}{\vartheta}
\renewcommand{\phi}{\varphi}
\renewcommand{\epsilon}{\varepsilon}

% Set notation
\newcommand{\st}{\,|\,}
\renewcommand{\vector}{\mathbf}
\renewcommand{\emptyset}[0]{\varnothing}
\renewcommand{\set}[1]{\left\{ #1 \right\}}
\providecommand{\setf}[1]{\mathcal #1}
\providecommand{\close}[1]{\overline{#1}}

\providecommand{\abs}[1]{\left | #1 \right |} 
\providecommand{\norm}[1]{\left \| #1 \right \|}
\providecommand{\inv}[1]{#1^{-1}}
\providecommand{\mean}[1]{\mathbb{E} \left [ #1 \right ]}

\DeclareMathOperator{\trace}{Tr}

\renewcommand{\tt}{\texttt}

\definecolor{darkgreen}{rgb}{0,0.5,0.25}
\definecolor{lightgrey}{rgb}{0.75,0.75,0.75}
\definecolor{grey}{rgb}{0.5,0.5,0.5}
\definecolor{darkgrey}{rgb}{0.25,0.25,0.25}

\linespread{1.5}

\lstset{language=C++}

\begin{document}

\maketitle

\section{Definizione dell'interfaccia}

Il namespace \tt{Geometry} contiene le classi relative alla manipolazione di oggetti geometrici primitivi (ad esempio segmenti, triangoli, quadrati, \dots), particolarmente utili nell'implementazione di formule di quadrature numerica, poiché contengono le funzioni per il passaggio di coordinate tra il dominio di riferimento $\hat{\Omega}$ e quello considerato $\Omega$. \\
Tale classe dovrà contenere tre tipi di istruzioni:
\begin{itemize}
	\item le trasformazioni delle coordinate dei punti dal riferimento $\hat{\Omega}$ a quello attuale $\Omega$,
	\item le trasformazioni inverse,
	\item le informazioni geometriche, come l'area del dominio e il determinante della matrice Jacobiana di $\vector{x}=\vector{x}(\hat{\vector{x}})$, fondamentali per l'implementazione delle formule di quadratura numerica.
\end{itemize}

L'unico dettaglio implementativo degno di nota è il costruttore, ideato per mettere in comunicazione la classe con la struttura dati della triangolazione. Infatti si è scelto di utilizzare la programmazione generica, al fine di rendere indipendente la nostra struttura, conservando al suo interno tutte le informazioni geometriche. Con l'utilizzo dei \emph{template} si lascia la possibilità all'utente di specializzare il solo costruttore, e non l'intera struttura dati, in base ad una particolare scelta di implementazione per la triangolazione.

\begin{lstlisting}
class Geometry {
	private:
		Matrix<double,2,2> A;
		Matrix<double,2,2> invA;
		Vector<double,2> b;

	public
		template <typename Face>
		Geometry (Face const & f);
};

template <>
Geometry::Geometry<MyOwnFaceType> (MyOwnFaceType const & f) {
	/* definizione di A, invA e b */
}
\end{lstlisting}

\section{La classe \tt{Triangle}}

Siccome nell'implementazione dei metodi ad elementi finiti avremo a che fare con delle triangolazioni di domini, vediamo come è stata implementata una classe di questo tipo per oggetti di forma triangolare, che chiameremo \tt{Triangle}. Quindi, considerato il triangolo $K$ di vertici $\vector{x}_0,\vector{x}_1,\vector{x}_2\in\R^2$, si è deciso di identificarlo, tramite la trasformazione affine $\vector{x}=A\hat{\vector{x}}+\vector{b}$, con il dominio di riferimento $\hat{K}$, che ha vertici
\[
\hat{\vector{x}}_0=(0,0),\quad
\hat{\vector{x}}_1=(1,0),\quad
\hat{\vector{x}}_2=(0,1).
\]
Ovviamente la mappa dovrà soddisfare le condizioni $\vector{x}_i=A\hat{\vector{x}}_i+\vector{b}$ con $i=0,1,2$, così da ottenere
\[
A = \left( \vector{x}_1 - \vector{x}_0 \middle| \vector{x}_2 - \vector{x}_0 \right), \quad
\vector{b} = \vector{x}_0.
\]
Detto questo è immediato definire l'interfaccia per la classe \tt{Triangle}, evitando di entrare nei dettagli dell'implementazione.
\begin{lstlisting}
class Triangle {
	
	/* Trasformazioni dal riferimento all'attuale */
	double x (double const & x, double const & y) const;
	double y (double const & x, double const & y) const;
	
	/* Trasformazioni inverse */
	double invx (double const & x, double const & y) const;
	double invy (double const & x, double const & y) const;
	
	/* Informazioni geometriche */
	double area () const;
	double det (double const & x, double const & y) const;
};
\end{lstlisting}

\end{document}
